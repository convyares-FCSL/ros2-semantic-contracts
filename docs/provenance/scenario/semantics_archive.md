# **Scenario Semantics**

This document defines the **semantic claims** made by each oracle scenario.

It answers the question:

> **What does scenario X assert about the observable world?**

This document does **not** track implementation status, backend coverage, or production adoption.
Those concerns are tracked separately.

Each entry defines:

* the **semantic invariant** being exercised
* the **scope and assumptions** of the scenario
* what **must be observable**
* what **must not** be inferred
* whether the claim is **normative** or a **hypothesis** awaiting validation

---

## **Conventions**

* **Normative**: derived from top-level ROS 2 specifications or core semantic contracts.
* **Baseline hypothesis**: expected behaviour inferred from implementation or ecosystem practice, not yet validated.
* **Policy-layer**: behaviour dependent on higher-level orchestration or conventions (e.g. Nav2).

---

## **Actions — Core Semantics**

<details>
<summary><b>A01 — Unique Goal Identity ("No Ghosts")</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A01_unique_goal_identity`

**Claim**
If a goal is rejected, it MUST NOT become observable as an active or completed goal.

**Observable assertions**
* A rejected goal ID never appears in status, feedback, or result streams.
* No terminal or intermediate state is emitted for the rejected goal.

**Non-claims**
* Does not assert how rejection is implemented.
* Does not assert timing guarantees.

</details>

<details>
<summary><b>A02 — Terminal State Immutability</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A02_terminal_immutable`

**Claim**

Once a goal reaches a terminal state, its terminal status is immutable.

**Observable assertions**

* Any subsequent attempt to change terminal state is rejected.
* No conflicting terminal events are emitted.

</details>

<details>
<summary><b>A03 — Unknown Goal Not Persistent</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A03_unknown_not_persistent`

**Claim**

Goals that are unknown to the system MUST NOT persist as observable entities.

**Observable assertions**

* An unknown goal ID is never observable.
* It is treated as if it was never created.

**Status**

* Scenario defined but not yet fully judged.

</details>

<details>
<summary><b>A04 — Valid Transitions Only</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A04_valid_transitions`

**Claim**

A goal can only transition between states defined in the goal state machine.

**Observable assertions**

* Invalid state transitions are rejected deterministically.
* Any attempt to transition outside of the defined set of states results in failure.

**Non-claims**

* Does not assert whether transitions are event-based or time-driven.

</details>

<details>
<summary><b>A05 — Invalid Transitions Rejected</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A05_invalid_transitions_rejected`

**Claim**

Invalid transitions are rejected by the system.

**Observable assertions**

* Any transition that is not part of the valid state machine is rejected.
* No state change occurs if the transition is invalid.

</details>

<details>
<summary><b>A06 — Status Updates Monotonic</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A06_status_updates_monotonic`

**Claim**

Goal status updates are monotonic.

**Observable assertions**

* Status can only advance or remain the same.
* Status can never regress.

</details>

<details>
<summary><b>A07 — Event Ordering Determined by Sequence, Not Wall-Clock Time</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A07_ordering_time_independent`

**Claim**

Events associated with a goal are ordered deterministically, independent of the wall-clock time.

**Observable assertions**

* Events follow the order in which they were generated by the system.
* Event timestamps or wall-clock time are not considered when determining order.

</details>

<details>
<summary><b>A08 — Cancellation Intent Observable</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A08_cancel_intent_observable`

**Claim**

The intent to cancel a goal must be observable.

**Observable assertions**

* A "cancel goal" request must be visible in goal status or feedback.
* The cancellation action is explicitly emitted as an event.

</details>

<details>
<summary><b>A09 — Cancel Resolution Policy-Defined</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A09_cancel_resolution_policy`

**Claim**

The outcome of a cancellation request is policy-defined.

**Observable assertions**

* The resolution of the cancellation request (whether accepted, rejected, or processed) is observable.
* The system must apply a policy to decide the result of the cancellation.

</details>

<details>
<summary><b>A10 — Result Visible After Terminal</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A10_result_visible_after_terminal`

**Claim**

The result of a goal is observable after it reaches a terminal state.

**Observable assertions**

* The goal result is available through event reporting.
* The result is persistent after the terminal state is reached.

</details>

<details>
<summary><b>A11 — Single Terminal Result</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/action_core.md`
**Provenance**: TL
**Scenario**: `A11_single_terminal_result`

**Claim**

A goal will only have one terminal result.

**Observable assertions**

* Once a goal is in a terminal state, there is no additional result produced.
* Multiple terminal events for the same goal are rejected.

</details>

<details>
<summary><b>A12 — Supersession via CANCELED</b> (Layer: Policy)</summary>

**Spec**: `docs/spec/action.md`
**Provenance**: COM
**Scenario**: `A12_supersession_cancelled`

**Claim**

The cancellation of a goal should supersede any previous results or state.

**Observable assertions**

* Once a goal is canceled, it will not produce any further results.
* The cancellation state should be observable as an event.
* There should be no conflict with any prior states or outcomes once the goal is canceled.

**Non-claims**

* Does not specify how or when the cancellation event occurs in relation to other system events.

</details>

<details>
<summary><b>A13 — Result Retention Non-Zero</b> (Layer: Policy)</summary>

**Spec**: `docs/spec/action.md`
**Provenance**: TL
**Scenario**: `A13_result_retention`

**Claim**

The result of a goal must be retained for observation after the goal terminates.

**Observable assertions**

* A goal's result is available for observation after the goal reaches a terminal state.
* The result should not be overwritten by subsequent state changes.

**Non-claims**

* Does not specify how long the result must be retained or whether it can be modified after termination.

</details>

<details>
<summary><b>A14 — Tooling Compatibility</b> (Layer: Tooling)</summary>

**Spec**: `docs/spec/action.md`
**Provenance**: TL
**Scenario**: `A14_tooling_compatibility`

**Claim**

The system should be compatible with external tooling as defined by the semantic contract.

**Observable assertions**

* External tooling must be able to interface with the goal management system in a predictable manner.
* Tooling should observe all expected events and state transitions.

**Non-claims**

* This does not guarantee that every external tool will be compatible, but it should cover major implementations.

</details>

---

## **Lifecycle — Core Semantics**

<details>
<summary><b>G01 — Inactive Suppresses Pubs</b> (Layer: Core)</summary>

**Spec**: `docs/spec/lifecycle.md`
**Provenance**: TL
**Scenario**: `G01_inactive_suppresses_pubs`

**Claim**

When a node is inactive, it should suppress any publication of messages.

**Observable assertions**

* No messages are published while the node is inactive.
* The system should not attempt to process or broadcast any message if the node is inactive.

**Non-claims**

* Does not define the method by which the node is set to inactive.

</details>

<details>
<summary><b>L01 — Only Defined Transitions</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L01_defined_transitions`

**Claim**

Only lifecycle transitions defined by the canonical state machine are permitted.

**Observable assertions**

* Invalid transitions are rejected deterministically.
* No partial state changes occur.

</details>

<details>
<summary><b>L02 — Invalid Transitions Rejected</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L02_invalid_transitions_rejected`

**Claim**

Invalid transitions are rejected by the system.

**Observable assertions**

* Any transition that is not part of the valid state machine is rejected.
* No state change occurs if the transition is invalid.

</details>

<details>
<summary><b>L03 — Intermediate States Hidden</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L03_intermediate_states_hidden`

**Claim**

Intermediate lifecycle states are not observable.

**Observable assertions**

* Only defined transitions and final states are visible to observers.
* Intermediate states are not part of the event stream.

</details>

<details>
<summary><b>L04 — Single Active Transition</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L04_single_active_transition`

**Claim**

Only one transition can be active at any given time.

**Observable assertions**

* If a transition is in progress, it must be the only active transition.
* Any attempt to trigger another transition during an active transition is rejected.

</details>

<details>
<summary><b>L05 — Concurrent Transition Rejected</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L05_concurrent_transition_rejected`

**Claim**

Concurrent transitions are rejected by the system.

**Observable assertions**

* Only one transition is processed at a time.
* Attempts to trigger another transition concurrently will fail.

</details>

<details>
<summary><b>L06 — ErrorProcessing Deterministic</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/lifecycle_core.md`
**Provenance**: TL
**Scenario**: `L06_error_processing_deterministic`

**Claim**

Error processing in the lifecycle is deterministic.

**Observable assertions**

* Any error condition must produce a defined, deterministic response.
* Errors do not cause unexpected side effects in the system.

</details>

<details>
<summary><b>L07 — GetState Reports Primary Only</b> (Layer: Core)</summary>

**Spec**: `docs/spec/lifecycle.md`
**Provenance**: TL
**Scenario**: `L07_get_state_primary`

**Claim**

The `GetState` service must only return the primary state.

**Observable assertions**

* Only the primary state is returned by `GetState`.
* Secondary or auxiliary states are not included in the response.

</details>

<details>
<summary><b>L08 — Rejection Observable</b> (Layer: Core)</summary>

**Spec**: `docs/spec/lifecycle.md`
**Provenance**: TL
**Scenario**: `L08_rejection_observable`

**Claim**

Rejection of a lifecycle transition must be observable.

**Observable assertions**

* A rejection event is emitted when a transition request is rejected.
* Rejection must be clear, including the reason for rejection.

</details>

<details>
<summary><b>L09 — TransitionEvent Emitted</b> (Layer: Core)</summary>

**Spec**: `docs/spec/lifecycle.md`
**Provenance**: TL
**Scenario**: `L09_transition_event_emitted`

**Claim**

A transition event is emitted when a transition occurs.

**Observable assertions**

* Events are triggered for every transition (whether successful or rejected).
* Transition events must be deterministic.

</details>

<details>
<summary><b>L10 — Shutdown Deterministic</b> (Layer: Core)</summary>

**Spec**: `docs/spec/lifecycle.md`
**Provenance**: TL
**Scenario**: `L10_shutdown_deterministic`

**Claim**

Shutdown of the node or system is deterministic.

**Observable assertions**

* Shutdown events occur in a predictable order.
* There are no unexpected shutdown side effects.

</details>

---

## **Parameters — Core Semantics**

<details>
<summary><b>P01 — No Fabricated Parameters</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P01_no_fabricated_params`

**Claim**

Parameters that have not been declared or implicitly allowed MUST NOT appear as observable state.

</details>

<details>
<summary><b>P02 — Dynamic Typing Rules</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P02_dynamic_typing_rules`

**Claim**

Parameters must support dynamic typing, allowing types to be defined and adjusted as needed.

**Observable assertions**

* Parameter types can be dynamically defined and modified.
* Attempts to assign incompatible types should be rejected.

**Non-claims**

* Does not specify how dynamically assigned types are managed within the system.

</details>

<details>
<summary><b>P03 — Redeclaration Fails</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P03_redeclaration_fails`

**Claim**

Attempting to redeclare an already-declared parameter must fail deterministically.

**Observable assertions**

* The second declaration attempt returns a failure outcome.
* No parameter state change occurs as a result of the failed attempt.

**Non-claims**

* Does not assert the error reason text.
* Does not assert whether the failure is silent or reported via events.

**Important note**

This scenario does **not** assert identity based on parameter name alone.
It asserts semantic redeclaration: a declaration attempt against an existing parameter identity.

</details>

<details>
<summary><b>P04 — No Partial Application</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P04_no_partial_application`

**Claim**

Partial parameter applications should not be externally observable.

**Observable assertions**

* Any partial application of parameters should not affect the system state or behavior until fully applied.

**Non-claims**

* Does not specify internal mechanisms for handling partial applications.

</details>

<details>
<summary><b>P05 — Read-Only Enforcement</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P05_readonly_enforcement`

**Claim**

Read-only parameters should be enforced, preventing modification after initialization.

**Observable assertions**

* Attempts to modify read-only parameters should result in rejection.
* The system should provide feedback when a read-only parameter modification is attempted.

**Non-claims**

* Does not specify whether the read-only state can be altered programmatically.

</details>

<details>
<summary><b>P06 — Unknown Parameters Rejected</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P06_unknown_params_rejected`

**Claim**

If undeclared parameters are not permitted, attempts to set unknown parameters MUST fail.

</details>

<details>
<summary><b>P07 — Change Record Ordering</b> (Layer: Core)</summary>

**Spec**: `docs/spec/core/parameter_core.md`
**Provenance**: TL
**Scenario**: `P07_change_record_ordering`

**Claim**

The system should respect a defined record ordering for parameter operations.

**Observable assertions**

* Parameters should be applied in a deterministic order based on the defined system logic.
* The order of parameter records should not vary unexpectedly across identical operations.

**Non-claims**

* Does not assert specific implementation details regarding how the order is maintained.

</details>

<details>
<summary><b>P08 — Unknown Types NOT_SET</b> (Layer: Core)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P08_unknown_types_not_set`

**Claim**

Unknown types should be represented with a `NOT_SET` value, signaling that the type is undefined.

**Observable assertions**

* If a parameter has an unknown type, it should be observable as `NOT_SET`.
* The system should not infer or make assumptions about the type of an unknown parameter.

**Non-claims**

* Does not specify how unknown types are handled internally.

</details>

<details>
<summary><b>P09 — Atomic Updates (External)</b> (Layer: Core)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P09_atomic_updates`

**Claim**

Parameter updates must be atomic and externally observable.

**Observable assertions**

* All updates to parameters must either succeed or fail as a whole.
* No partial updates should be visible to the observer.

**Non-claims**

* Does not define how atomicity is managed at the backend level.

</details>

<details>
<summary><b>P10 — Rejected Updates Silent</b> (Layer: Core)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P10_rejected_updates_silent`

**Claim**

Rejected updates should not emit any parameter change events.

**Observable assertions**

* The system should not emit events for rejected parameter updates.
* No state change or event occurs for rejected updates.

**Non-claims**

* Does not specify why or how the rejection occurs.

</details>

<details>
<summary><b>P11 — Events Describe Changes</b> (Layer: Core)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P11_events_describe_changes`

**Claim**

Parameter events must describe changes in parameter values.

**Observable assertions**

* Events must provide clear descriptions of changes in parameter values, types, or statuses.

**Non-claims**

* Does not specify the format of the event details.

</details>

<details>
<summary><b>P12 — Describe Unknown Consistent</b> (Layer: Core)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P12_describe_unknown_consistent`

**Claim**

Describing an unknown parameter MUST produce a consistent, non-error response.

**Observable assertions**

* The response shape is stable.
* Unknown parameters are not fabricated as declared.

</details>

<details>
<summary><b>P13 — List Complete and Stable</b> (Layer: Tooling)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P13_list_complete_stable`

**Claim**

A list of parameters must be complete and stable across identical queries.

**Observable assertions**

* Parameter lists returned via queries should be exhaustive and unchanged if the system state remains unchanged.

**Non-claims**

* Does not assert how lists are returned internally or how often the list is updated.

</details>

<details>
<summary><b>P14 — Deletion Reported via Events</b> (Layer: Policy)</summary>

**Spec**: `docs/spec/parameters.md`
**Provenance**: TL
**Scenario**: `P14_deletion_reported_events`

**Claim**

Parameter deletion should be observable via parameter events.

**Observable assertions**

* When a parameter is deleted, an event should be emitted to signal the deletion.
* The deletion event should include all relevant information about the parameter.

**Non-claims**

* Does not specify how deletion is triggered or managed within the system.

</details>

---

## **System Semantics (Hypotheses)**

<details>
<summary><b>S01 — Load Node Observable</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S01_load_node_observable`

**Claim**

The loading of a node must be observable to external systems.

**Observable assertions**

* External systems must observe the node's loading state through events or logs.
* The node's state must change from inactive to active when loaded.

**Non-claims**

* Does not define the exact mechanism of node loading or how observability is implemented.

</details>

<details>
<summary><b>S02 — Load Failure Clean</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S02_load_failure_clean`

**Claim**

If a node fails to load, the system must clean up the failure and ensure no resources are left in an invalid state.

**Observable assertions**

* If the node fails to load, any resources allocated to it should be released.
* The system must emit an event or log indicating the failure and cleanup.

**Non-claims**

* Does not specify how cleanup is managed internally.

</details>

<details>
<summary><b>S03 — Unload Node Destroyed</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S03_unload_node_destroyed`

**Claim**

Unloading a node should result in its destruction, ensuring that all resources are freed.

**Observable assertions**

* Once the node is unloaded, no resources related to it should remain.
* The system must emit an event indicating the node’s destruction.

**Non-claims**

* Does not define the mechanism for node destruction or resource management.

</details>

<details>
<summary><b>S04 — Unique Node IDs</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S04_unique_node_ids`

**Claim**

Every node in the system must have a unique identifier.

**Observable assertions**

* Each node must be assigned a unique ID that can be observed externally.
* The system should reject any attempt to assign the same ID to multiple nodes.

**Non-claims**

* Does not define how the unique IDs are generated or managed internally.

</details>

<details>
<summary><b>S05 — Concurrent Load Deterministic</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S05_concurrent_load_deterministic`

**Claim**

The concurrent loading of nodes must be deterministic, ensuring that the order of node loading is predictable.

**Observable assertions**

* Node loading should occur in a specific order as defined by the system.
* The order of events should be predictable and not vary across identical system states.

**Non-claims**

* Does not define the exact method for determining the order of concurrent node loading.

</details>

<details>
<summary><b>S06 — Remaps Apply at Load</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/composition.md`
**Provenance**: NONE
**Scenario**: `S06_remaps_apply_load`

**Claim**

Any remappings must be applied at the time of node load.

**Observable assertions**

* If remaps are defined, they must be applied as the node is being loaded.
* The system must emit an event indicating that remaps have been successfully applied.

**Non-claims**

* Does not define how remaps are handled or applied internally.

</details>

<details>
<summary><b>S07 — Explicit Ownership</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/executor.md`
**Provenance**: NONE
**Scenario**: `S07_explicit_ownership`

**Claim**

Ownership of system resources must be explicit and clearly defined.

**Observable assertions**

* The system must provide explicit ownership details for resources that are managed.
* Ownership transfers or changes must be observable externally.

**Non-claims**

* Does not define the internal method by which ownership is tracked or enforced.

</details>

<details>
<summary><b>S08 — Bounded Spin Modes</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/executor.md`
**Provenance**: NONE
**Scenario**: `S08_bounded_spin_modes`

**Claim**

The system must support bounded spin modes to prevent excessive processing.

**Observable assertions**

* The system must emit an event or status indicating the current spin mode.
* Bounded spin modes must prevent any resource from being monopolized or overwhelmed.

**Non-claims**

* Does not specify how the system determines or enforces bounded spin modes.

</details>

<details>
<summary><b>S09 — Shutdown Bounded</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/executor.md`
**Provenance**: NONE
**Scenario**: `S09_shutdown_bounded`

**Claim**

The system must ensure that the shutdown process is bounded and predictable.

**Observable assertions**

* Shutdown must occur in a deterministic manner, with resources being freed in a specific order.
* The system should not enter an indefinite shutdown state or block indefinitely.

**Non-claims**

* Does not define the specific steps or sequence of shutdown procedures.

</details>

<details>
<summary><b>S10 — Callback Failure Visible</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/executor.md`
**Provenance**: NONE
**Scenario**: `S10_callback_failure_visible`

**Claim**

Any callback failures must be visible to the system and external observers.

**Observable assertions**

* Callback failures must trigger events or logs that are observable externally.
* The system must provide details on the failure cause where appropriate.

**Non-claims**

* Does not define how callback failures are logged or reported within the system.

</details>

<details>
<summary><b>S11 — Lifecycle-Executor Safety</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/executor.md`
**Provenance**: NONE
**Scenario**: `S11_lifecycle_executor_safety`

**Claim**

The lifecycle and executor must be safe to use in all scenarios, preventing errors or unexpected behavior.

**Observable assertions**

* The system must enforce safety checks to prevent unsafe lifecycle or executor states.
* Errors related to lifecycle and executor management should be observable.

**Non-claims**

* Does not define how lifecycle safety is enforced internally.

</details>

<details>
<summary><b>S12 — Lifecycle Orchestration</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/ecosystem.md`
**Provenance**: COM
**Scenario**: `S12_lifecycle_orchestration`

**Claim**

The lifecycle orchestration must ensure that all components of the system interact correctly with each other.

**Observable assertions**

* The system must provide events or logs indicating the status of lifecycle orchestration.
* Any misalignments in lifecycle stages should be observable.

**Non-claims**

* Does not specify how orchestration is managed between different components.

</details>

<details>
<summary><b>S13 — Liveness Detection</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/ecosystem.md`
**Provenance**: COM
**Scenario**: `S13_liveness_detection`

**Claim**

The system must include liveness detection to monitor the health of nodes.

**Observable assertions**

* Liveness checks should be observable externally.
* The system should emit an event when a node becomes unresponsive or fails its liveness check.

**Non-claims**

* Does not define the frequency or method of performing liveness checks.

</details>

<details>
<summary><b>S14 — Tooling Interoperability</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/ecosystem.md`
**Provenance**: COM
**Scenario**: `S14_tooling_interoperability`

**Claim**

The system must be compatible with a range of external tooling, allowing seamless integration.

**Observable assertions**

* External tooling must be able to interface with the system and receive necessary data.
* The system should produce compatible output for tooling that interacts with it.

**Non-claims**

* Does not specify which tooling is required or supported for interoperability.

</details>

<details>
<summary><b>S15 — Explicit Ownership/Lifetime</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/system_contract.md`
**Provenance**: NONE
**Scenario**: `S15_explicit_ownership_lifetime`

**Claim**

Ownership and lifetime of resources in the system must be explicit and clearly defined.

**Observable assertions**

* The system must expose clear ownership information for resources.
* The lifetime of resources must be finite and observable externally.

**Non-claims**

* Does not specify how ownership and lifetime are managed or tracked internally.

</details>

<details>
<summary><b>S16 — Deterministic Bringup/Teardown</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/system_contract.md`
**Provenance**: NONE
**Scenario**: `S16_deterministic_bringup`

**Claim**

The system’s bringup and teardown must be deterministic, ensuring consistent behavior during startup and shutdown.

**Observable assertions**

* The bringup and teardown process should be observable and deterministic.
* The system must provide feedback during these processes, and the outcome should be predictable.

**Non-claims**

* Does not define the exact steps or method for bringup or teardown.

</details>

<details>
<summary><b>S17 — No Hidden Execution</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/system_contract.md`
**Provenance**: NONE
**Scenario**: `S17_no_hidden_execution`

**Claim**

All execution in the system must be observable and explicit, with no hidden background processes.

**Observable assertions**

* All system operations and processes must be observable through logs or events.
* The system must not have any hidden processes that are not visible to users or observers.

**Non-claims**

* Does not define how hidden execution is prevented or detected.

</details>

<details>
<summary><b>S18 — Observable Failure</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/system_contract.md`
**Provenance**: NONE
**Scenario**: `S18_observable_failure`

**Claim**

Any failure in the system must be observable, providing clear feedback to external systems or users.

**Observable assertions**

* Failures should be observable through events, logs, or error codes.
* The system must provide context for any failures to aid in diagnosis.

**Non-claims**

* Does not define how failures are classified or logged internally.

</details>

<details>
<summary><b>S19 — Graph Hygiene</b> (Layer: System)</summary>

**Spec**: `docs/spec/system/system_contract.md`
**Provenance**: NONE
**Scenario**: `S19_graph_hygiene`

**Claim**

The system must maintain a clean and well-organized internal graph of nodes and resources.

**Observable assertions**

* The system should not contain redundant or disconnected nodes.
* Any changes to the internal graph should be observable.

**Non-claims**

* Does not specify how graph hygiene is maintained or enforced.

</details>